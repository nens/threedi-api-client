# coding: utf-8

"""
    3Di API

    3Di simulation API (latest stable version: v3)   Framework release: 1.0.64   3Di core release: 2.1.2  deployed on:  03:05PM (UTC) on September 15, 2021  # noqa: E501

    The version of the OpenAPI document: v3
    Contact: info@nelen-schuurmans.nl
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from threedi_api_client.openapi.api_client import ApiClient
from threedi_api_client.openapi.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class V3BetaApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def schematisations_create(self, data, **kwargs):  # noqa: E501
        """schematisations_create  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Schematisation data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_create_with_http_info(data, **kwargs)  # noqa: E501

    def schematisations_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """schematisations_create  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param Schematisation data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_delete(self, id, **kwargs):  # noqa: E501
        """schematisations_delete  # noqa: E501

        Schematisation can only be deleted when all commited revisions are deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_delete_with_http_info(id, **kwargs)  # noqa: E501

    def schematisations_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """schematisations_delete  # noqa: E501

        Schematisation can only be deleted when all commited revisions are deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_latest_revision(self, id, **kwargs):  # noqa: E501
        """Get the latest committed revision.  # noqa: E501

        For retrieving all revisions use: `/revisions/?schematisation__id=xx`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_latest_revision(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_latest_revision_with_http_info(id, **kwargs)  # noqa: E501

    def schematisations_latest_revision_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the latest committed revision.  # noqa: E501

        For retrieving all revisions use: `/revisions/?schematisation__id=xx`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_latest_revision_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_latest_revision" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_latest_revision`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{id}/latest_revision/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_list(self, **kwargs):  # noqa: E501
        """schematisations_list  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str name__iexact:
        :param str name__contains:
        :param str name__icontains:
        :param str name__in: Multiple values may be separated by commas.
        :param str name__startswith:
        :param str name__istartswith:
        :param str name__endswith:
        :param str name__regex:
        :param str slug:
        :param str slug__iexact:
        :param str slug__contains:
        :param str slug__icontains:
        :param str slug__in: Multiple values may be separated by commas.
        :param str slug__startswith:
        :param str slug__istartswith:
        :param str slug__endswith:
        :param str slug__regex:
        :param str owner__name:
        :param str owner__name__iexact:
        :param str owner__name__contains:
        :param str owner__name__icontains:
        :param str owner__name__in: Multiple values may be separated by commas.
        :param str owner__name__startswith:
        :param str owner__name__istartswith:
        :param str owner__name__endswith:
        :param str owner__name__regex:
        :param str owner__unique_id:
        :param str owner__unique_id__iexact:
        :param str owner__unique_id__contains:
        :param str owner__unique_id__icontains:
        :param str owner__unique_id__in: Multiple values may be separated by commas.
        :param str owner__unique_id__startswith:
        :param str owner__unique_id__istartswith:
        :param str owner__unique_id__endswith:
        :param str owner__unique_id__regex:
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_list_with_http_info(**kwargs)  # noqa: E501

    def schematisations_list_with_http_info(self, **kwargs):  # noqa: E501
        """schematisations_list  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str name__iexact:
        :param str name__contains:
        :param str name__icontains:
        :param str name__in: Multiple values may be separated by commas.
        :param str name__startswith:
        :param str name__istartswith:
        :param str name__endswith:
        :param str name__regex:
        :param str slug:
        :param str slug__iexact:
        :param str slug__contains:
        :param str slug__icontains:
        :param str slug__in: Multiple values may be separated by commas.
        :param str slug__startswith:
        :param str slug__istartswith:
        :param str slug__endswith:
        :param str slug__regex:
        :param str owner__name:
        :param str owner__name__iexact:
        :param str owner__name__contains:
        :param str owner__name__icontains:
        :param str owner__name__in: Multiple values may be separated by commas.
        :param str owner__name__startswith:
        :param str owner__name__istartswith:
        :param str owner__name__endswith:
        :param str owner__name__regex:
        :param str owner__unique_id:
        :param str owner__unique_id__iexact:
        :param str owner__unique_id__contains:
        :param str owner__unique_id__icontains:
        :param str owner__unique_id__in: Multiple values may be separated by commas.
        :param str owner__unique_id__startswith:
        :param str owner__unique_id__istartswith:
        :param str owner__unique_id__endswith:
        :param str owner__unique_id__regex:
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'slug',
            'slug__iexact',
            'slug__contains',
            'slug__icontains',
            'slug__in',
            'slug__startswith',
            'slug__istartswith',
            'slug__endswith',
            'slug__regex',
            'owner__name',
            'owner__name__iexact',
            'owner__name__contains',
            'owner__name__icontains',
            'owner__name__in',
            'owner__name__startswith',
            'owner__name__istartswith',
            'owner__name__endswith',
            'owner__name__regex',
            'owner__unique_id',
            'owner__unique_id__iexact',
            'owner__unique_id__contains',
            'owner__unique_id__icontains',
            'owner__unique_id__in',
            'owner__unique_id__startswith',
            'owner__unique_id__istartswith',
            'owner__unique_id__endswith',
            'owner__unique_id__regex',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'slug' in local_var_params and local_var_params['slug'] is not None:  # noqa: E501
            query_params.append(('slug', local_var_params['slug']))  # noqa: E501
        if 'slug__iexact' in local_var_params and local_var_params['slug__iexact'] is not None:  # noqa: E501
            query_params.append(('slug__iexact', local_var_params['slug__iexact']))  # noqa: E501
        if 'slug__contains' in local_var_params and local_var_params['slug__contains'] is not None:  # noqa: E501
            query_params.append(('slug__contains', local_var_params['slug__contains']))  # noqa: E501
        if 'slug__icontains' in local_var_params and local_var_params['slug__icontains'] is not None:  # noqa: E501
            query_params.append(('slug__icontains', local_var_params['slug__icontains']))  # noqa: E501
        if 'slug__in' in local_var_params and local_var_params['slug__in'] is not None:  # noqa: E501
            query_params.append(('slug__in', local_var_params['slug__in']))  # noqa: E501
        if 'slug__startswith' in local_var_params and local_var_params['slug__startswith'] is not None:  # noqa: E501
            query_params.append(('slug__startswith', local_var_params['slug__startswith']))  # noqa: E501
        if 'slug__istartswith' in local_var_params and local_var_params['slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('slug__istartswith', local_var_params['slug__istartswith']))  # noqa: E501
        if 'slug__endswith' in local_var_params and local_var_params['slug__endswith'] is not None:  # noqa: E501
            query_params.append(('slug__endswith', local_var_params['slug__endswith']))  # noqa: E501
        if 'slug__regex' in local_var_params and local_var_params['slug__regex'] is not None:  # noqa: E501
            query_params.append(('slug__regex', local_var_params['slug__regex']))  # noqa: E501
        if 'owner__name' in local_var_params and local_var_params['owner__name'] is not None:  # noqa: E501
            query_params.append(('owner__name', local_var_params['owner__name']))  # noqa: E501
        if 'owner__name__iexact' in local_var_params and local_var_params['owner__name__iexact'] is not None:  # noqa: E501
            query_params.append(('owner__name__iexact', local_var_params['owner__name__iexact']))  # noqa: E501
        if 'owner__name__contains' in local_var_params and local_var_params['owner__name__contains'] is not None:  # noqa: E501
            query_params.append(('owner__name__contains', local_var_params['owner__name__contains']))  # noqa: E501
        if 'owner__name__icontains' in local_var_params and local_var_params['owner__name__icontains'] is not None:  # noqa: E501
            query_params.append(('owner__name__icontains', local_var_params['owner__name__icontains']))  # noqa: E501
        if 'owner__name__in' in local_var_params and local_var_params['owner__name__in'] is not None:  # noqa: E501
            query_params.append(('owner__name__in', local_var_params['owner__name__in']))  # noqa: E501
        if 'owner__name__startswith' in local_var_params and local_var_params['owner__name__startswith'] is not None:  # noqa: E501
            query_params.append(('owner__name__startswith', local_var_params['owner__name__startswith']))  # noqa: E501
        if 'owner__name__istartswith' in local_var_params and local_var_params['owner__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('owner__name__istartswith', local_var_params['owner__name__istartswith']))  # noqa: E501
        if 'owner__name__endswith' in local_var_params and local_var_params['owner__name__endswith'] is not None:  # noqa: E501
            query_params.append(('owner__name__endswith', local_var_params['owner__name__endswith']))  # noqa: E501
        if 'owner__name__regex' in local_var_params and local_var_params['owner__name__regex'] is not None:  # noqa: E501
            query_params.append(('owner__name__regex', local_var_params['owner__name__regex']))  # noqa: E501
        if 'owner__unique_id' in local_var_params and local_var_params['owner__unique_id'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id', local_var_params['owner__unique_id']))  # noqa: E501
        if 'owner__unique_id__iexact' in local_var_params and local_var_params['owner__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__iexact', local_var_params['owner__unique_id__iexact']))  # noqa: E501
        if 'owner__unique_id__contains' in local_var_params and local_var_params['owner__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__contains', local_var_params['owner__unique_id__contains']))  # noqa: E501
        if 'owner__unique_id__icontains' in local_var_params and local_var_params['owner__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__icontains', local_var_params['owner__unique_id__icontains']))  # noqa: E501
        if 'owner__unique_id__in' in local_var_params and local_var_params['owner__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__in', local_var_params['owner__unique_id__in']))  # noqa: E501
        if 'owner__unique_id__startswith' in local_var_params and local_var_params['owner__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__startswith', local_var_params['owner__unique_id__startswith']))  # noqa: E501
        if 'owner__unique_id__istartswith' in local_var_params and local_var_params['owner__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__istartswith', local_var_params['owner__unique_id__istartswith']))  # noqa: E501
        if 'owner__unique_id__endswith' in local_var_params and local_var_params['owner__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__endswith', local_var_params['owner__unique_id__endswith']))  # noqa: E501
        if 'owner__unique_id__regex' in local_var_params and local_var_params['owner__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('owner__unique_id__regex', local_var_params['owner__unique_id__regex']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_partial_update(self, id, data, **kwargs):  # noqa: E501
        """schematisations_partial_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_partial_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_partial_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def schematisations_partial_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """schematisations_partial_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_partial_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_read(self, id, **kwargs):  # noqa: E501
        """schematisations_read  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_read_with_http_info(id, **kwargs)  # noqa: E501

    def schematisations_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """schematisations_read  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_commit(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Commit the revision  # noqa: E501

        The `commit_message` can be used to descripe the changes.  The `force_as` parameter allows to override the default behaviour of committing the revision with the already assigned revision number.  In case another user has already committed a revision with the same number, an HTTP 409 status code is returned.  In this case you can either: 1) Save the revision with a higher revision number using    `force_as` = `new_revision`, effectively overwriting changes    from the other user. 2) Save the revision under a new schematisation using    `force_as` = `new_schematisation` and specifying    a `schematisation_name`.  If you want to merge your changes with the changes from the other user, you need to download his/hers revision locally and merge it yourselves.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_commit(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param Commit data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_commit_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_commit_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Commit the revision  # noqa: E501

        The `commit_message` can be used to descripe the changes.  The `force_as` parameter allows to override the default behaviour of committing the revision with the already assigned revision number.  In case another user has already committed a revision with the same number, an HTTP 409 status code is returned.  In this case you can either: 1) Save the revision with a higher revision number using    `force_as` = `new_revision`, effectively overwriting changes    from the other user. 2) Save the revision under a new schematisation using    `force_as` = `new_schematisation` and specifying    a `schematisation_name`.  If you want to merge your changes with the changes from the other user, you need to download his/hers revision locally and merge it yourselves.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_commit_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param Commit data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_commit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_commit`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_commit`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_commit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/commit/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_create(self, schematisation_pk, data, **kwargs):  # noqa: E501
        """Create a new revision  # noqa: E501

        Creates a clone of the last committed revision (if present) by default except when empty=true is passed in the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create(schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param CreateRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_create_with_http_info(schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_create_with_http_info(self, schematisation_pk, data, **kwargs):  # noqa: E501
        """Create a new revision  # noqa: E501

        Creates a clone of the last committed revision (if present) by default except when empty=true is passed in the data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create_with_http_info(schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param CreateRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_create_threedimodel(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_create_threedimodel  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create_threedimodel(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SchematisationRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ThreediModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_create_threedimodel_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_create_threedimodel_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_create_threedimodel  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_create_threedimodel_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SchematisationRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ThreediModel, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_create_threedimodel" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_create_threedimodel`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_create_threedimodel`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_create_threedimodel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/create_threedimodel/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ThreediModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_delete(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_delete  # noqa: E501

        Provide the revision id to delete the revision  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_delete(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param DestroyRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_delete_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_delete_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_delete  # noqa: E501

        Provide the revision id to delete the revision  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_delete_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param DestroyRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_delete`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_list(self, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_list  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_list(schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param float number:
        :param str commit_message:
        :param str commit_message__iexact:
        :param str commit_message__contains:
        :param str commit_message__icontains:
        :param str commit_message__in: Multiple values may be separated by commas.
        :param str commit_message__startswith:
        :param str commit_message__istartswith:
        :param str commit_message__endswith:
        :param str commit_message__regex:
        :param float schematisation__id:
        :param str schematisation__slug:
        :param str schematisation__slug__iexact:
        :param str schematisation__slug__contains:
        :param str schematisation__slug__icontains:
        :param str schematisation__slug__in: Multiple values may be separated by commas.
        :param str schematisation__slug__startswith:
        :param str schematisation__slug__istartswith:
        :param str schematisation__slug__endswith:
        :param str schematisation__slug__regex:
        :param str schematisation__owner__name:
        :param str schematisation__owner__name__iexact:
        :param str schematisation__owner__name__contains:
        :param str schematisation__owner__name__icontains:
        :param str schematisation__owner__name__in: Multiple values may be separated by commas.
        :param str schematisation__owner__name__startswith:
        :param str schematisation__owner__name__istartswith:
        :param str schematisation__owner__name__endswith:
        :param str schematisation__owner__name__regex:
        :param str schematisation__owner__unique_id:
        :param str schematisation__owner__unique_id__iexact:
        :param str schematisation__owner__unique_id__contains:
        :param str schematisation__owner__unique_id__icontains:
        :param str schematisation__owner__unique_id__in: Multiple values may be separated by commas.
        :param str schematisation__owner__unique_id__startswith:
        :param str schematisation__owner__unique_id__istartswith:
        :param str schematisation__owner__unique_id__endswith:
        :param str schematisation__owner__unique_id__regex:
        :param str committed:
        :param str archived:
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_list_with_http_info(schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_list_with_http_info(self, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_list  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_list_with_http_info(schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str schematisation_pk: (required)
        :param float number:
        :param str commit_message:
        :param str commit_message__iexact:
        :param str commit_message__contains:
        :param str commit_message__icontains:
        :param str commit_message__in: Multiple values may be separated by commas.
        :param str commit_message__startswith:
        :param str commit_message__istartswith:
        :param str commit_message__endswith:
        :param str commit_message__regex:
        :param float schematisation__id:
        :param str schematisation__slug:
        :param str schematisation__slug__iexact:
        :param str schematisation__slug__contains:
        :param str schematisation__slug__icontains:
        :param str schematisation__slug__in: Multiple values may be separated by commas.
        :param str schematisation__slug__startswith:
        :param str schematisation__slug__istartswith:
        :param str schematisation__slug__endswith:
        :param str schematisation__slug__regex:
        :param str schematisation__owner__name:
        :param str schematisation__owner__name__iexact:
        :param str schematisation__owner__name__contains:
        :param str schematisation__owner__name__icontains:
        :param str schematisation__owner__name__in: Multiple values may be separated by commas.
        :param str schematisation__owner__name__startswith:
        :param str schematisation__owner__name__istartswith:
        :param str schematisation__owner__name__endswith:
        :param str schematisation__owner__name__regex:
        :param str schematisation__owner__unique_id:
        :param str schematisation__owner__unique_id__iexact:
        :param str schematisation__owner__unique_id__contains:
        :param str schematisation__owner__unique_id__icontains:
        :param str schematisation__owner__unique_id__in: Multiple values may be separated by commas.
        :param str schematisation__owner__unique_id__startswith:
        :param str schematisation__owner__unique_id__istartswith:
        :param str schematisation__owner__unique_id__endswith:
        :param str schematisation__owner__unique_id__regex:
        :param str committed:
        :param str archived:
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'schematisation_pk',
            'number',
            'commit_message',
            'commit_message__iexact',
            'commit_message__contains',
            'commit_message__icontains',
            'commit_message__in',
            'commit_message__startswith',
            'commit_message__istartswith',
            'commit_message__endswith',
            'commit_message__regex',
            'schematisation__id',
            'schematisation__slug',
            'schematisation__slug__iexact',
            'schematisation__slug__contains',
            'schematisation__slug__icontains',
            'schematisation__slug__in',
            'schematisation__slug__startswith',
            'schematisation__slug__istartswith',
            'schematisation__slug__endswith',
            'schematisation__slug__regex',
            'schematisation__owner__name',
            'schematisation__owner__name__iexact',
            'schematisation__owner__name__contains',
            'schematisation__owner__name__icontains',
            'schematisation__owner__name__in',
            'schematisation__owner__name__startswith',
            'schematisation__owner__name__istartswith',
            'schematisation__owner__name__endswith',
            'schematisation__owner__name__regex',
            'schematisation__owner__unique_id',
            'schematisation__owner__unique_id__iexact',
            'schematisation__owner__unique_id__contains',
            'schematisation__owner__unique_id__icontains',
            'schematisation__owner__unique_id__in',
            'schematisation__owner__unique_id__startswith',
            'schematisation__owner__unique_id__istartswith',
            'schematisation__owner__unique_id__endswith',
            'schematisation__owner__unique_id__regex',
            'committed',
            'archived',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []
        if 'number' in local_var_params and local_var_params['number'] is not None:  # noqa: E501
            query_params.append(('number', local_var_params['number']))  # noqa: E501
        if 'commit_message' in local_var_params and local_var_params['commit_message'] is not None:  # noqa: E501
            query_params.append(('commit_message', local_var_params['commit_message']))  # noqa: E501
        if 'commit_message__iexact' in local_var_params and local_var_params['commit_message__iexact'] is not None:  # noqa: E501
            query_params.append(('commit_message__iexact', local_var_params['commit_message__iexact']))  # noqa: E501
        if 'commit_message__contains' in local_var_params and local_var_params['commit_message__contains'] is not None:  # noqa: E501
            query_params.append(('commit_message__contains', local_var_params['commit_message__contains']))  # noqa: E501
        if 'commit_message__icontains' in local_var_params and local_var_params['commit_message__icontains'] is not None:  # noqa: E501
            query_params.append(('commit_message__icontains', local_var_params['commit_message__icontains']))  # noqa: E501
        if 'commit_message__in' in local_var_params and local_var_params['commit_message__in'] is not None:  # noqa: E501
            query_params.append(('commit_message__in', local_var_params['commit_message__in']))  # noqa: E501
        if 'commit_message__startswith' in local_var_params and local_var_params['commit_message__startswith'] is not None:  # noqa: E501
            query_params.append(('commit_message__startswith', local_var_params['commit_message__startswith']))  # noqa: E501
        if 'commit_message__istartswith' in local_var_params and local_var_params['commit_message__istartswith'] is not None:  # noqa: E501
            query_params.append(('commit_message__istartswith', local_var_params['commit_message__istartswith']))  # noqa: E501
        if 'commit_message__endswith' in local_var_params and local_var_params['commit_message__endswith'] is not None:  # noqa: E501
            query_params.append(('commit_message__endswith', local_var_params['commit_message__endswith']))  # noqa: E501
        if 'commit_message__regex' in local_var_params and local_var_params['commit_message__regex'] is not None:  # noqa: E501
            query_params.append(('commit_message__regex', local_var_params['commit_message__regex']))  # noqa: E501
        if 'schematisation__id' in local_var_params and local_var_params['schematisation__id'] is not None:  # noqa: E501
            query_params.append(('schematisation__id', local_var_params['schematisation__id']))  # noqa: E501
        if 'schematisation__slug' in local_var_params and local_var_params['schematisation__slug'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug', local_var_params['schematisation__slug']))  # noqa: E501
        if 'schematisation__slug__iexact' in local_var_params and local_var_params['schematisation__slug__iexact'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__iexact', local_var_params['schematisation__slug__iexact']))  # noqa: E501
        if 'schematisation__slug__contains' in local_var_params and local_var_params['schematisation__slug__contains'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__contains', local_var_params['schematisation__slug__contains']))  # noqa: E501
        if 'schematisation__slug__icontains' in local_var_params and local_var_params['schematisation__slug__icontains'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__icontains', local_var_params['schematisation__slug__icontains']))  # noqa: E501
        if 'schematisation__slug__in' in local_var_params and local_var_params['schematisation__slug__in'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__in', local_var_params['schematisation__slug__in']))  # noqa: E501
        if 'schematisation__slug__startswith' in local_var_params and local_var_params['schematisation__slug__startswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__startswith', local_var_params['schematisation__slug__startswith']))  # noqa: E501
        if 'schematisation__slug__istartswith' in local_var_params and local_var_params['schematisation__slug__istartswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__istartswith', local_var_params['schematisation__slug__istartswith']))  # noqa: E501
        if 'schematisation__slug__endswith' in local_var_params and local_var_params['schematisation__slug__endswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__endswith', local_var_params['schematisation__slug__endswith']))  # noqa: E501
        if 'schematisation__slug__regex' in local_var_params and local_var_params['schematisation__slug__regex'] is not None:  # noqa: E501
            query_params.append(('schematisation__slug__regex', local_var_params['schematisation__slug__regex']))  # noqa: E501
        if 'schematisation__owner__name' in local_var_params and local_var_params['schematisation__owner__name'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name', local_var_params['schematisation__owner__name']))  # noqa: E501
        if 'schematisation__owner__name__iexact' in local_var_params and local_var_params['schematisation__owner__name__iexact'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__iexact', local_var_params['schematisation__owner__name__iexact']))  # noqa: E501
        if 'schematisation__owner__name__contains' in local_var_params and local_var_params['schematisation__owner__name__contains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__contains', local_var_params['schematisation__owner__name__contains']))  # noqa: E501
        if 'schematisation__owner__name__icontains' in local_var_params and local_var_params['schematisation__owner__name__icontains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__icontains', local_var_params['schematisation__owner__name__icontains']))  # noqa: E501
        if 'schematisation__owner__name__in' in local_var_params and local_var_params['schematisation__owner__name__in'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__in', local_var_params['schematisation__owner__name__in']))  # noqa: E501
        if 'schematisation__owner__name__startswith' in local_var_params and local_var_params['schematisation__owner__name__startswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__startswith', local_var_params['schematisation__owner__name__startswith']))  # noqa: E501
        if 'schematisation__owner__name__istartswith' in local_var_params and local_var_params['schematisation__owner__name__istartswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__istartswith', local_var_params['schematisation__owner__name__istartswith']))  # noqa: E501
        if 'schematisation__owner__name__endswith' in local_var_params and local_var_params['schematisation__owner__name__endswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__endswith', local_var_params['schematisation__owner__name__endswith']))  # noqa: E501
        if 'schematisation__owner__name__regex' in local_var_params and local_var_params['schematisation__owner__name__regex'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__name__regex', local_var_params['schematisation__owner__name__regex']))  # noqa: E501
        if 'schematisation__owner__unique_id' in local_var_params and local_var_params['schematisation__owner__unique_id'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id', local_var_params['schematisation__owner__unique_id']))  # noqa: E501
        if 'schematisation__owner__unique_id__iexact' in local_var_params and local_var_params['schematisation__owner__unique_id__iexact'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__iexact', local_var_params['schematisation__owner__unique_id__iexact']))  # noqa: E501
        if 'schematisation__owner__unique_id__contains' in local_var_params and local_var_params['schematisation__owner__unique_id__contains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__contains', local_var_params['schematisation__owner__unique_id__contains']))  # noqa: E501
        if 'schematisation__owner__unique_id__icontains' in local_var_params and local_var_params['schematisation__owner__unique_id__icontains'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__icontains', local_var_params['schematisation__owner__unique_id__icontains']))  # noqa: E501
        if 'schematisation__owner__unique_id__in' in local_var_params and local_var_params['schematisation__owner__unique_id__in'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__in', local_var_params['schematisation__owner__unique_id__in']))  # noqa: E501
        if 'schematisation__owner__unique_id__startswith' in local_var_params and local_var_params['schematisation__owner__unique_id__startswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__startswith', local_var_params['schematisation__owner__unique_id__startswith']))  # noqa: E501
        if 'schematisation__owner__unique_id__istartswith' in local_var_params and local_var_params['schematisation__owner__unique_id__istartswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__istartswith', local_var_params['schematisation__owner__unique_id__istartswith']))  # noqa: E501
        if 'schematisation__owner__unique_id__endswith' in local_var_params and local_var_params['schematisation__owner__unique_id__endswith'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__endswith', local_var_params['schematisation__owner__unique_id__endswith']))  # noqa: E501
        if 'schematisation__owner__unique_id__regex' in local_var_params and local_var_params['schematisation__owner__unique_id__regex'] is not None:  # noqa: E501
            query_params.append(('schematisation__owner__unique_id__regex', local_var_params['schematisation__owner__unique_id__regex']))  # noqa: E501
        if 'committed' in local_var_params and local_var_params['committed'] is not None:  # noqa: E501
            query_params.append(('committed', local_var_params['committed']))  # noqa: E501
        if 'archived' in local_var_params and local_var_params['archived'] is not None:  # noqa: E501
            query_params.append(('archived', local_var_params['archived']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_partial_update(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_partial_update  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_partial_update(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SchematisationRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_partial_update_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_partial_update_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_partial_update  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_partial_update_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SchematisationRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_partial_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_create(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for creating a raster.  # noqa: E501

        Optional md5sum can be added to detect if the file already has been uploaded and perform de-duplication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_create(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RasterCreate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_create_with_http_info(revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_create_with_http_info(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for creating a raster.  # noqa: E501

        Optional md5sum can be added to detect if the file already has been uploaded and perform de-duplication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_create_with_http_info(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RasterCreate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_create`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_delete(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_delete(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_delete_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_delete_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_delete_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_delete`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_download(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_download(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_download_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_download_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_download_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_download`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_download`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_list(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_list(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_list_with_http_info(revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_list_with_http_info(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_list_with_http_info(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2002, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_list`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_partial_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_partial_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_partial_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_partial_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_read(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_read(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_read_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_read_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_read_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_read`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_read`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionRaster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_update  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionRaster data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionRaster, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionRaster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_rasters_upload(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_upload  # noqa: E501

        Endpoint for uploading a raster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_upload(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param Upload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_rasters_upload_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_rasters_upload_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_rasters_upload  # noqa: E501

        Endpoint for uploading a raster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_rasters_upload_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision raster. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param Upload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_rasters_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_rasters_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/rasters/{id}/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_read(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_read  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_read(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_read_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_read_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_read  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_read_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_read`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_sqlite_delete(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_delete  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_delete(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_sqlite_delete_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_sqlite_delete_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_delete  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_delete_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_sqlite_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_sqlite_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_sqlite_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/sqlite/delete/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_sqlite_download(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_download(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Download
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_sqlite_download_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_sqlite_download_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_sqlite_download  # noqa: E501

        Endpoint for downloading files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_download_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Download, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_sqlite_download" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_sqlite_download`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_sqlite_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/sqlite/download/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Download',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_sqlite_upload(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the sqlite file, the file should be zipped (deflate).  # noqa: E501

        Replaces the present sqlite file if there already exists one.  Optional md5sum can be added to detect if the file already has been uploaded and perform de-duplication. (md5sum of the compressed sqlite file)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_upload(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SqliteFileUpload data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Upload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_sqlite_upload_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_sqlite_upload_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """Endpoint for uploading the sqlite file, the file should be zipped (deflate).  # noqa: E501

        Replaces the present sqlite file if there already exists one.  Optional md5sum can be added to detect if the file already has been uploaded and perform de-duplication. (md5sum of the compressed sqlite file)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_sqlite_upload_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SqliteFileUpload data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Upload, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_sqlite_upload" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_sqlite_upload`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_sqlite_upload`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_sqlite_upload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/sqlite/upload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Upload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_create(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_create  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_create(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_create_with_http_info(revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_create_with_http_info(self, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_create  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_create_with_http_info(revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_create`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_create`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_tasks_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_delete(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_delete  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_delete(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_delete_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_delete_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_delete  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_delete_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_delete`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_delete`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_list(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_list  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_list(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_list_with_http_info(revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_list_with_http_info(self, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_list  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_list_with_http_info(revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2003, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'revision_pk',
            'schematisation_pk',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_list`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_partial_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_partial_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_partial_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_partial_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_partial_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_partial_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_partial_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_tasks_partial_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_read(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_read  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_read(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_read_with_http_info(id, revision_pk, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_read_with_http_info(self, id, revision_pk, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_read  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_read_with_http_info(id, revision_pk, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_read`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_read`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_tasks_update(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_update(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: RevisionTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_tasks_update_with_http_info(id, revision_pk, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_tasks_update_with_http_info(self, id, revision_pk, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_tasks_update  # noqa: E501

        View revision tasks  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_tasks_update_with_http_info(id, revision_pk, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision task. (required)
        :param str revision_pk: (required)
        :param str schematisation_pk: (required)
        :param RevisionTask data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(RevisionTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'revision_pk',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_tasks_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_tasks_update`")  # noqa: E501
        # verify the required parameter 'revision_pk' is set
        if self.api_client.client_side_validation and ('revision_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['revision_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `revision_pk` when calling `schematisations_revisions_tasks_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_tasks_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_tasks_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'revision_pk' in local_var_params:
            path_params['revision_pk'] = local_var_params['revision_pk']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{revision_pk}/tasks/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RevisionTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_threedimodels(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_threedimodels  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_threedimodels(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ThreediModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_threedimodels_with_http_info(id, schematisation_pk, **kwargs)  # noqa: E501

    def schematisations_revisions_threedimodels_with_http_info(self, id, schematisation_pk, **kwargs):  # noqa: E501
        """schematisations_revisions_threedimodels  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_threedimodels_with_http_info(id, schematisation_pk, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ThreediModel], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_threedimodels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_threedimodels`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_threedimodels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/threedimodels/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ThreediModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_revisions_update(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_update  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_update(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SchematisationRevision data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SchematisationRevision
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_revisions_update_with_http_info(id, schematisation_pk, data, **kwargs)  # noqa: E501

    def schematisations_revisions_update_with_http_info(self, id, schematisation_pk, data, **kwargs):  # noqa: E501
        """schematisations_revisions_update  # noqa: E501

        Manage revisions of schematisations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_revisions_update_with_http_info(id, schematisation_pk, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this revision. (required)
        :param str schematisation_pk: (required)
        :param SchematisationRevision data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SchematisationRevision, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'schematisation_pk',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_revisions_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_revisions_update`")  # noqa: E501
        # verify the required parameter 'schematisation_pk' is set
        if self.api_client.client_side_validation and ('schematisation_pk' not in local_var_params or  # noqa: E501
                                                        local_var_params['schematisation_pk'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schematisation_pk` when calling `schematisations_revisions_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_revisions_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'schematisation_pk' in local_var_params:
            path_params['schematisation_pk'] = local_var_params['schematisation_pk']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{schematisation_pk}/revisions/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SchematisationRevision',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def schematisations_update(self, id, data, **kwargs):  # noqa: E501
        """schematisations_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_update(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Schematisation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.schematisations_update_with_http_info(id, data, **kwargs)  # noqa: E501

    def schematisations_update_with_http_info(self, id, data, **kwargs):  # noqa: E501
        """schematisations_update  # noqa: E501

        Manage schematisations  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.schematisations_update_with_http_info(id, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this schematisation. (required)
        :param Schematisation data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Schematisation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method schematisations_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `schematisations_update`")  # noqa: E501
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `schematisations_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/schematisations/{id}/', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Schematisation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_create(self, data, **kwargs):  # noqa: E501
        """Create a (optionally cloned) simulation template from this simulation.  # noqa: E501

        A simulation template is actually nothing more than a simulation with a special status. It's immutable after creation and can only used to create new simulations, or be deleted.  Simulations 'upgraded' to simulations templates can't be directly run. The 'from_template' endpoints allows to create a new simulation from a template in a runnable state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_create(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateTemplate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Template
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_create_with_http_info(data, **kwargs)  # noqa: E501

    def simulation_templates_create_with_http_info(self, data, **kwargs):  # noqa: E501
        """Create a (optionally cloned) simulation template from this simulation.  # noqa: E501

        A simulation template is actually nothing more than a simulation with a special status. It's immutable after creation and can only used to create new simulations, or be deleted.  Simulations 'upgraded' to simulations templates can't be directly run. The 'from_template' endpoints allows to create a new simulation from a template in a runnable state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_create_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param CreateTemplate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Template, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulation_templates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/simulation_templates/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Template',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_delete(self, id, **kwargs):  # noqa: E501
        """simulation_templates_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_delete_with_http_info(id, **kwargs)  # noqa: E501

    def simulation_templates_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """simulation_templates_delete  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulation_templates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/simulation_templates/{id}/', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_list(self, **kwargs):  # noqa: E501
        """simulation_templates_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str name__iexact:
        :param str name__contains:
        :param str name__icontains:
        :param str name__in: Multiple values may be separated by commas.
        :param str name__startswith:
        :param str name__istartswith:
        :param str name__endswith:
        :param str name__regex:
        :param str uuid:
        :param str uuid__iexact:
        :param str uuid__contains:
        :param str uuid__icontains:
        :param str uuid__in: Multiple values may be separated by commas.
        :param str uuid__startswith:
        :param str uuid__istartswith:
        :param str uuid__endswith:
        :param str uuid__regex:
        :param str created__date:
        :param str created__date__gt:
        :param str created__date__gte:
        :param str created__date__lt:
        :param str created__date__lte:
        :param float created__year:
        :param float created__year__gt:
        :param float created__year__gte:
        :param float created__year__lt:
        :param float created__year__lte:
        :param float created__month:
        :param float created__month__lte:
        :param float created__day:
        :param float created__day__lt:
        :param float simulation__threedimodel__id:
        :param float simulation__threedimodel__id__range: Multiple values may be separated by commas.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_list_with_http_info(**kwargs)  # noqa: E501

    def simulation_templates_list_with_http_info(self, **kwargs):  # noqa: E501
        """simulation_templates_list  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name:
        :param str name__iexact:
        :param str name__contains:
        :param str name__icontains:
        :param str name__in: Multiple values may be separated by commas.
        :param str name__startswith:
        :param str name__istartswith:
        :param str name__endswith:
        :param str name__regex:
        :param str uuid:
        :param str uuid__iexact:
        :param str uuid__contains:
        :param str uuid__icontains:
        :param str uuid__in: Multiple values may be separated by commas.
        :param str uuid__startswith:
        :param str uuid__istartswith:
        :param str uuid__endswith:
        :param str uuid__regex:
        :param str created__date:
        :param str created__date__gt:
        :param str created__date__gte:
        :param str created__date__lt:
        :param str created__date__lte:
        :param float created__year:
        :param float created__year__gt:
        :param float created__year__gte:
        :param float created__year__lt:
        :param float created__year__lte:
        :param float created__month:
        :param float created__month__lte:
        :param float created__day:
        :param float created__day__lt:
        :param float simulation__threedimodel__id:
        :param float simulation__threedimodel__id__range: Multiple values may be separated by commas.
        :param int limit: Number of results to return per page.
        :param int offset: The initial index from which to return the results.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2004, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name',
            'name__iexact',
            'name__contains',
            'name__icontains',
            'name__in',
            'name__startswith',
            'name__istartswith',
            'name__endswith',
            'name__regex',
            'uuid',
            'uuid__iexact',
            'uuid__contains',
            'uuid__icontains',
            'uuid__in',
            'uuid__startswith',
            'uuid__istartswith',
            'uuid__endswith',
            'uuid__regex',
            'created__date',
            'created__date__gt',
            'created__date__gte',
            'created__date__lt',
            'created__date__lte',
            'created__year',
            'created__year__gt',
            'created__year__gte',
            'created__year__lt',
            'created__year__lte',
            'created__month',
            'created__month__lte',
            'created__day',
            'created__day__lt',
            'simulation__threedimodel__id',
            'simulation__threedimodel__id__range',
            'limit',
            'offset'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_list" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'name__iexact' in local_var_params and local_var_params['name__iexact'] is not None:  # noqa: E501
            query_params.append(('name__iexact', local_var_params['name__iexact']))  # noqa: E501
        if 'name__contains' in local_var_params and local_var_params['name__contains'] is not None:  # noqa: E501
            query_params.append(('name__contains', local_var_params['name__contains']))  # noqa: E501
        if 'name__icontains' in local_var_params and local_var_params['name__icontains'] is not None:  # noqa: E501
            query_params.append(('name__icontains', local_var_params['name__icontains']))  # noqa: E501
        if 'name__in' in local_var_params and local_var_params['name__in'] is not None:  # noqa: E501
            query_params.append(('name__in', local_var_params['name__in']))  # noqa: E501
        if 'name__startswith' in local_var_params and local_var_params['name__startswith'] is not None:  # noqa: E501
            query_params.append(('name__startswith', local_var_params['name__startswith']))  # noqa: E501
        if 'name__istartswith' in local_var_params and local_var_params['name__istartswith'] is not None:  # noqa: E501
            query_params.append(('name__istartswith', local_var_params['name__istartswith']))  # noqa: E501
        if 'name__endswith' in local_var_params and local_var_params['name__endswith'] is not None:  # noqa: E501
            query_params.append(('name__endswith', local_var_params['name__endswith']))  # noqa: E501
        if 'name__regex' in local_var_params and local_var_params['name__regex'] is not None:  # noqa: E501
            query_params.append(('name__regex', local_var_params['name__regex']))  # noqa: E501
        if 'uuid' in local_var_params and local_var_params['uuid'] is not None:  # noqa: E501
            query_params.append(('uuid', local_var_params['uuid']))  # noqa: E501
        if 'uuid__iexact' in local_var_params and local_var_params['uuid__iexact'] is not None:  # noqa: E501
            query_params.append(('uuid__iexact', local_var_params['uuid__iexact']))  # noqa: E501
        if 'uuid__contains' in local_var_params and local_var_params['uuid__contains'] is not None:  # noqa: E501
            query_params.append(('uuid__contains', local_var_params['uuid__contains']))  # noqa: E501
        if 'uuid__icontains' in local_var_params and local_var_params['uuid__icontains'] is not None:  # noqa: E501
            query_params.append(('uuid__icontains', local_var_params['uuid__icontains']))  # noqa: E501
        if 'uuid__in' in local_var_params and local_var_params['uuid__in'] is not None:  # noqa: E501
            query_params.append(('uuid__in', local_var_params['uuid__in']))  # noqa: E501
        if 'uuid__startswith' in local_var_params and local_var_params['uuid__startswith'] is not None:  # noqa: E501
            query_params.append(('uuid__startswith', local_var_params['uuid__startswith']))  # noqa: E501
        if 'uuid__istartswith' in local_var_params and local_var_params['uuid__istartswith'] is not None:  # noqa: E501
            query_params.append(('uuid__istartswith', local_var_params['uuid__istartswith']))  # noqa: E501
        if 'uuid__endswith' in local_var_params and local_var_params['uuid__endswith'] is not None:  # noqa: E501
            query_params.append(('uuid__endswith', local_var_params['uuid__endswith']))  # noqa: E501
        if 'uuid__regex' in local_var_params and local_var_params['uuid__regex'] is not None:  # noqa: E501
            query_params.append(('uuid__regex', local_var_params['uuid__regex']))  # noqa: E501
        if 'created__date' in local_var_params and local_var_params['created__date'] is not None:  # noqa: E501
            query_params.append(('created__date', local_var_params['created__date']))  # noqa: E501
        if 'created__date__gt' in local_var_params and local_var_params['created__date__gt'] is not None:  # noqa: E501
            query_params.append(('created__date__gt', local_var_params['created__date__gt']))  # noqa: E501
        if 'created__date__gte' in local_var_params and local_var_params['created__date__gte'] is not None:  # noqa: E501
            query_params.append(('created__date__gte', local_var_params['created__date__gte']))  # noqa: E501
        if 'created__date__lt' in local_var_params and local_var_params['created__date__lt'] is not None:  # noqa: E501
            query_params.append(('created__date__lt', local_var_params['created__date__lt']))  # noqa: E501
        if 'created__date__lte' in local_var_params and local_var_params['created__date__lte'] is not None:  # noqa: E501
            query_params.append(('created__date__lte', local_var_params['created__date__lte']))  # noqa: E501
        if 'created__year' in local_var_params and local_var_params['created__year'] is not None:  # noqa: E501
            query_params.append(('created__year', local_var_params['created__year']))  # noqa: E501
        if 'created__year__gt' in local_var_params and local_var_params['created__year__gt'] is not None:  # noqa: E501
            query_params.append(('created__year__gt', local_var_params['created__year__gt']))  # noqa: E501
        if 'created__year__gte' in local_var_params and local_var_params['created__year__gte'] is not None:  # noqa: E501
            query_params.append(('created__year__gte', local_var_params['created__year__gte']))  # noqa: E501
        if 'created__year__lt' in local_var_params and local_var_params['created__year__lt'] is not None:  # noqa: E501
            query_params.append(('created__year__lt', local_var_params['created__year__lt']))  # noqa: E501
        if 'created__year__lte' in local_var_params and local_var_params['created__year__lte'] is not None:  # noqa: E501
            query_params.append(('created__year__lte', local_var_params['created__year__lte']))  # noqa: E501
        if 'created__month' in local_var_params and local_var_params['created__month'] is not None:  # noqa: E501
            query_params.append(('created__month', local_var_params['created__month']))  # noqa: E501
        if 'created__month__lte' in local_var_params and local_var_params['created__month__lte'] is not None:  # noqa: E501
            query_params.append(('created__month__lte', local_var_params['created__month__lte']))  # noqa: E501
        if 'created__day' in local_var_params and local_var_params['created__day'] is not None:  # noqa: E501
            query_params.append(('created__day', local_var_params['created__day']))  # noqa: E501
        if 'created__day__lt' in local_var_params and local_var_params['created__day__lt'] is not None:  # noqa: E501
            query_params.append(('created__day__lt', local_var_params['created__day__lt']))  # noqa: E501
        if 'simulation__threedimodel__id' in local_var_params and local_var_params['simulation__threedimodel__id'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id', local_var_params['simulation__threedimodel__id']))  # noqa: E501
        if 'simulation__threedimodel__id__range' in local_var_params and local_var_params['simulation__threedimodel__id__range'] is not None:  # noqa: E501
            query_params.append(('simulation__threedimodel__id__range', local_var_params['simulation__threedimodel__id__range']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/simulation_templates/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulation_templates_read(self, id, **kwargs):  # noqa: E501
        """simulation_templates_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_read(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Template
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulation_templates_read_with_http_info(id, **kwargs)  # noqa: E501

    def simulation_templates_read_with_http_info(self, id, **kwargs):  # noqa: E501
        """simulation_templates_read  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulation_templates_read_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this template. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Template, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulation_templates_read" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulation_templates_read`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/simulation_templates/{id}/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Template',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_clone(self, id, **kwargs):  # noqa: E501
        """Clone the simulation.  # noqa: E501

        Clones the simulation in a runnable state, only events & initials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_clone(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Simulation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_clone_with_http_info(id, **kwargs)  # noqa: E501

    def simulations_clone_with_http_info(self, id, **kwargs):  # noqa: E501
        """Clone the simulation.  # noqa: E501

        Clones the simulation in a runnable state, only events & initials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_clone_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: A unique integer value identifying this simulation. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Simulation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_clone" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `simulations_clone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/simulations/{id}/clone/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Simulation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulations_from_template(self, data, **kwargs):  # noqa: E501
        """simulations_from_template  # noqa: E501

        Create a (new/cloned) simulation from a simulation template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_from_template(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FromTemplate data: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Simulation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulations_from_template_with_http_info(data, **kwargs)  # noqa: E501

    def simulations_from_template_with_http_info(self, data, **kwargs):  # noqa: E501
        """simulations_from_template  # noqa: E501

        Create a (new/cloned) simulation from a simulation template  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulations_from_template_with_http_info(data, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param FromTemplate data: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Simulation, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulations_from_template" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'data' is set
        if self.api_client.client_side_validation and ('data' not in local_var_params or  # noqa: E501
                                                        local_var_params['data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `data` when calling `simulations_from_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'data' in local_var_params:
            body_params = local_var_params['data']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v3-beta/simulations/from_template/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Simulation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
